# ADR-001: Размещение логики Saga-оркестрации в архитектуре OrchestrPay

## Контекст

Платёжная система OrchestrPay реализует сложный бизнес-процесс обработки платежей на маркетплейсах с использованием паттерна Saga для управления распределёнными транзакциями. Процесс включает несколько этапов:

1. Списание средств с клиента
2. Проверка транзакции в сервисе FraudCheck (с возможностью ручной проверки)
3. Перевод средств контрагенту
4. Отправка уведомлений клиенту

В случае сбоя на любом из этапов требуется выполнить компенсирующие транзакции (например, возврат средств клиенту).

### Проблема

Необходимо принять решение о размещении логики Saga-оркестрации в архитектуре системы. Существует два основных подхода:

1. **Встроить оркестрацию в доменный сервис** (Payment Service)
2. **Создать отдельный сервис-оркестратор** (Payment Orchestrator Service)

### Ключевые требования

- **Отказоустойчивость**: система должна корректно обрабатывать сбои на любом этапе
- **Наблюдаемость**: необходима прозрачность состояния транзакций для бизнеса и службы безопасности
- **Масштабируемость**: возможность горизонтального масштабирования под нагрузкой
- **Гибкость**: лёгкость изменения бизнес-процесса и добавления новых этапов
- **Простота разработки и поддержки**: минимизация сложности для команды разработки
- **SLA**: менее 5 секунд для успешных транзакций в 90% случаев

### Технологический стек

- **Camunda BPMN**: для реализации Saga-оркестрации
- **PostgreSQL**: хранение состояний транзакций
- **Redis**: кэширование промежуточных данных

## Рассмотренные варианты

### Вариант №1 «Оркестрация внутри Payment Service»

#### Описание

Логика Saga-оркестрации встраивается непосредственно в Payment Service. Сервис становится ответственным за:
- Управление жизненным циклом платежа
- Координацию вызовов других сервисов (FraudCheck, Notification)
- Управление состояниями транзакций
- Выполнение компенсирующих транзакций

#### Архитектура

```
┌─────────────────────────────────────────────────────┐
│            Payment Service                          │
│                                                     │
│  ┌──────────────────────────────────────────────┐  │
│  │   Payment API Layer                          │  │
│  └──────────────┬───────────────────────────────┘  │
│                 │                                   │
│  ┌──────────────▼───────────────────────────────┐  │
│  │   Saga Orchestration Engine                  │  │
│  │   (Camunda BPMN)                             │  │
│  │   - State Machine                            │  │
│  │   - Compensation Logic                       │  │
│  │   - Retry Mechanisms                         │  │
│  └──────┬─────────────────────┬─────────────────┘  │
│         │                     │                     │
│  ┌──────▼──────┐       ┌──────▼─────────────────┐  │
│  │  Payment    │       │  External Service      │  │
│  │  Domain     │       │  Clients               │  │
│  │  Logic      │       │  - FraudCheck Client   │  │
│  │             │       │  - Notification Client │  │
│  └─────────────┘       └────────────────────────┘  │
│                                                     │
│  ┌──────────────────────────────────────────────┐  │
│  │   PostgreSQL                                 │  │
│  │   - Payments                                 │  │
│  │   - Saga State                               │  │
│  └──────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────┘
                    │              │
        ┌───────────┘              └──────────┐
        │                                     │
┌───────▼────────┐                   ┌────────▼────────┐
│  FraudCheck    │                   │  Notification   │
│  Service       │                   │  Service        │
└────────────────┘                   └─────────────────┘
```

#### Особенности реализации

- Payment Service содержит встроенный Camunda BPMN Engine
- Все BPMN-процессы хранятся внутри сервиса
- Состояния Saga сохраняются в той же БД, что и доменные данные о платежах
- Сервис использует синхронные вызовы к FraudCheck и Notification с retry-механизмами

### Вариант №2 «Отдельный сервис Payment Orchestrator»

#### Описание

Создаётся выделенный микросервис Payment Orchestrator, ответственный исключительно за координацию платёжного процесса. Payment Service фокусируется только на доменной логике управления платежами.

#### Архитектура

```
┌──────────────────────────────────────────────────────┐
│         Payment Orchestrator Service                 │
│                                                      │
│  ┌────────────────────────────────────────────────┐ │
│  │   Orchestration API                            │ │
│  └────────────┬───────────────────────────────────┘ │
│               │                                      │
│  ┌────────────▼───────────────────────────────────┐ │
│  │   Saga Orchestration Engine                    │ │
│  │   (Camunda BPMN)                               │ │
│  │   - State Machine                              │ │
│  │   - Compensation Logic                         │ │
│  │   - Retry Mechanisms                           │ │
│  └────┬──────────┬──────────┬─────────────────────┘ │
│       │          │          │                        │
│  ┌────▼──────────▼──────────▼───────────────────┐   │
│  │   Service Clients Layer                      │   │
│  │   - Payment Client                           │   │
│  │   - FraudCheck Client                        │   │
│  │   - Notification Client                      │   │
│  └──────────────────────────────────────────────┘   │
│                                                      │
│  ┌────────────────────────────────────────────────┐ │
│  │   PostgreSQL (Saga State Only)               │  │
│  └────────────────────────────────────────────────┘ │
└──────────────────────────────────────────────────────┘
         │              │                │
    ┌────┘              │                └────┐
    │                   │                     │
┌───▼──────────┐  ┌─────▼────────┐  ┌────────▼────────┐
│  Payment     │  │  FraudCheck  │  │  Notification   │
│  Service     │  │  Service     │  │  Service        │
│              │  │              │  │                 │
│ ┌──────────┐ │  │              │  │                 │
│ │PostgreSQL│ │  │              │  │                 │
│ │(Payments)│ │  │              │  │                 │
│ └──────────┘ │  │              │  │                 │
└──────────────┘  └──────────────┘  └─────────────────┘
```

#### Особенности реализации

- Payment Orchestrator - независимый микросервис с Camunda BPMN Engine
- Имеет собственную БД для хранения состояний Saga
- Payment Service упрощается до CRUD-операций над платежами и предоставляет API для оркестратора
- Все межсервисные взаимодействия проходят через оркестратор
- Возможность использования асинхронной коммуникации (message broker) между оркестратором и доменными сервисами

## Сравнение альтернатив

| Критерий | Вариант №1 «Оркестрация в Payment Service» | Вариант №2 «Отдельный Orchestrator» |
|----------|---------------------------------------------|--------------------------------------|
| **Преимущества** | - Проще в разработке и развёртывании (один сервис)<br>- Меньше сетевых вызовов (нет дополнительного hop)<br>- Лучшая производительность (lower latency)<br>- Транзакционная согласованность данных платежа и состояния Saga<br>- Проще отладка и трассировка<br>- Меньше инфраструктурных затрат | - Чёткое разделение ответственности (SRP)<br>- Легче повторно использовать оркестратор для других процессов<br>- Независимое масштабирование оркестрации и доменной логики<br>- Упрощает Payment Service (фокус на домене)<br>- Легче заменить оркестрационный движок<br>- Изоляция сбоев оркестрации от доменного сервиса |
| **Недостатки** | - Нарушение Single Responsibility Principle<br>- Сложнее независимое масштабирование<br>- Payment Service "раздувается" оркестрационной логикой<br>- Сложнее повторное использование оркестрации<br>- Зависимость от Camunda в доменном сервисе | - Дополнительная сложность архитектуры<br>- Дополнительный сетевой hop (latency)<br>- Сложнее обеспечить транзакционность<br>- Больше точек отказа<br>- Сложнее отладка распределённого процесса<br>- Дополнительные инфраструктурные затраты<br>- Overhead на поддержку ещё одного сервиса |

### Детальное сравнение по критериям

#### 1. Производительность (Performance)

| Вариант №1 | Вариант №2 |
|------------|------------|
| (+) Меньше latency за счёт отсутствия дополнительного сетевого вызова к оркестратору | (~) Дополнительный network hop добавляет 10-50ms latency на каждый вызов |
| (+) Меньше сериализации/десериализации данных | (~) Дополнительная сериализация при каждом обращении к Payment Service |
| (+) Проще достичь SLA <5s для 90% транзакций | (~) Риск не уложиться в SLA из-за дополнительных сетевых вызовов |

#### 2. Масштабируемость (Scalability)

| Вариант №1 | Вариант №2 |
|------------|------------|
| (~) Масштабирование Payment Service влечёт масштабирование Camunda Engine (может быть избыточно) | (+) Независимое масштабирование: можно масштабировать оркестратор отдельно от Payment Service |
| (~) Нагрузка на Camunda и доменную логику масштабируется вместе | (+) Можно выделить больше ресурсов оркестратору в периоды высокой нагрузки |

#### 3. Разделение ответственности (Separation of Concerns)

| Вариант №1 | Вариант №2 |
|------------|------------|
| (-) Payment Service смешивает доменную логику и оркестрацию | (+) Чёткое разделение: Orchestrator управляет процессом, Payment Service управляет данными |
| (-) Нарушение Single Responsibility Principle | (+) Каждый сервис имеет одну чётко определённую ответственность |

#### 4. Сложность разработки и поддержки (Development & Maintenance)

| Вариант №1 | Вариант №2 |
|------------|------------|
| (+) Проще разрабатывать: всё в одном месте | (~) Сложнее: нужно разрабатывать и поддерживать два сервиса |
| (+) Проще отладка: один процесс, одни логи | (-) Сложнее отладка: логи распределены по сервисам |
| (+) Проще трассировка (один сервис) | (~) Необходимы distributed tracing инструменты (Jaeger) |
| (+) Меньше CI/CD пайплайнов | (-) Дополнительный CI/CD пайплайн для оркестратора |

#### 5. Отказоустойчивость (Resilience)

| Вариант №1 | Вариант №2 |
|------------|------------|
| (~) Сбой в Camunda Engine влияет на весь Payment Service | (+) Изоляция сбоев: проблемы в оркестраторе не влияют на доступность Payment API |
| (~) Одна точка отказа для всей платёжной функциональности | (+) Payment Service может продолжать работу в ограниченном режиме |
| (+) Проще восстановление после сбоя | (~) Сложнее восстановление: нужно синхронизировать состояние двух сервисов |

#### 6. Гибкость и переиспользование (Flexibility & Reusability)

| Вариант №1 | Вариант №2 |
|------------|------------|
| (-) Оркестрация привязана к Payment Service | (+) Orchestrator может использоваться для других бизнес-процессов (возвраты, подписки) |
| (-) Сложно добавить альтернативные платёжные потоки | (+) Легко добавлять новые процессы без изменения Payment Service |
| (~) Изменение оркестрации требует деплоя Payment Service | (+) Изменение процесса не требует деплоя доменных сервисов |

#### 7. Стоимость инфраструктуры (Infrastructure Cost)

| Вариант №1 | Вариант №2 |
|------------|------------|
| (+) Один сервис, одна БД, меньше ресурсов | (-) Два сервиса, две БД, больше вычислительных ресурсов |
| (+) Меньше operational overhead | (-) Больше мониторинга, логирования, метрик |

#### 8. Соответствие текущей стадии проекта

| Вариант №1 | Вариант №2 |
|------------|------------|
| (+) MVP уже развёрнут, система работает | (~) Требует значительной реорганизации архитектуры |
| (+) Команда небольшая, проще поддерживать один сервис | (-) Требует большей координации между командами |
| (+) Быстрее time-to-market для новых фич | (~) Дольше разработка из-за распределённой архитектуры |

## Принятое решение

**Вариант №1: Оркестрация внутри Payment Service**

### Обоснование

Решение принято в пользу встраивания Saga-оркестрации в Payment Service по следующим ключевым причинам:

#### 1. Соответствие текущему этапу развития компании

OrchestrPay является стартапом с MVP-платформой. На текущем этапе важнее:
- **Скорость разработки и вывода на рынок**: один сервис проще разрабатывать, тестировать и деплоить
- **Ограниченные ресурсы команды**: небольшая команда может эффективнее работать с монолитным подходом
- **Быстрая итерация**: изменения в одном месте ускоряют разработку новых функций

#### 2. Производительность и соответствие SLA

Критичным требованием является SLA <5 секунд для 90% транзакций:
- Отсутствие дополнительного network hop между оркестратором и Payment Service экономит 10-50ms на каждый вызов
- В платёжном потоке минимум 3-4 обращения к Payment Service (создание, списание, статусы), что даёт экономию 30-200ms
- Это критично для соблюдения жёсткого SLA

#### 3. Упрощение отладки и наблюдаемости

Платёжные операции требуют высокой наблюдаемости для бизнеса и безопасности:
- Все логи платежа и его оркестрации находятся в одном месте
- Проще трассировка: не нужны сложные distributed tracing инструменты на старте
- Быстрее расследование инцидентов: всё состояние в одной БД

#### 4. Транзакционная целостность

Payment Service хранит и доменные данные платежа, и состояние Saga в одной БД:
- Гарантия консистентности между данными платежа и его оркестрацией
- Проще обеспечить ACID-свойства критичных операций
- Меньше риска рассогласования состояний при сбоях

#### 5. Меньшая инфраструктурная сложность

На этапе MVP важна простота:
- Один сервис → один CI/CD пайплайн
- Одна БД → проще резервное копирование и миграции
- Меньше точек мониторинга и алертинга
- Ниже operational overhead для DevOps/SRE команды

#### 6. Достаточная гибкость для текущих требований

Анализ требований показывает, что:
- На текущий момент есть только один основной платёжный процесс
- Дополнительные процессы (возвраты) являются частью того же домена и логично размещать их в Payment Service
- Переиспользование оркестратора для других доменов не планируется в ближайшей перспективе

### Компромиссы и риски

При выборе Варианта №1 мы осознаём следующие компромиссы:

#### Принятые компромиссы:
1. **Нарушение SRP**: Payment Service имеет две ответственности (домен + оркестрация)
2. **Связность**: доменная логика и оркестрация развиваются вместе
3. **Масштабирование**: невозможно масштабировать оркестрацию независимо от домена

#### Меры по минимизации рисков:
1. **Модульная структура внутри сервиса**: чёткое разделение пакетов для domain, orchestration, api
2. **Использование ArchUnit**: автоматические проверки архитектурных ограничений
3. **Подготовка к рефакторингу**: изоляция оркестрационной логики для возможного выделения в будущем

## Дата принятия

30 сентября 2025

## Последнее обновление

30 сентября 2025